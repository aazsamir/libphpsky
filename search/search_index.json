{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Libphpsky","text":"<p>Libphpsky is a PHP library that provides automatically generated from lexicons, fully typed classes for working with Bluesky and ATProtocol.</p>"},{"location":"#features","title":"Features","text":"<ul> <li>Comprehensive interaction with the ATProtocol</li> <li>Statically typed queries, procedures and objects</li> <li>Authorization and automatic session management</li> <li>Query caching</li> <li>Amphp client support</li> <li>Subscriptions over WebSockets</li> <li>Custom lexicons support</li> </ul> <p>Check out Getting Started for quick introduction.</p>"},{"location":"01_getting_started/","title":"Getting started","text":"<p>Libphpsky is a PHP library for interacting with AT Protocol.</p>"},{"location":"01_getting_started/#installation","title":"Installation","text":"<p>You can install the package via composer:</p> <pre><code>composer require aazsamir/libphpsky\n</code></pre> <p>If you are using Laravel, you can use the libphpsky-laravel package.</p> <pre><code>composer require aazsamir/libphpsky-laravel\n</code></pre> <p>If you are using Symfony, you can use the libphpsky-symfony package.</p> <pre><code>composer require aazsamir/libphpsky-symfony\n</code></pre>"},{"location":"01_getting_started/#usage","title":"Usage","text":"<p>Get list of posts from a <code>bsky.app</code> user:</p> <pre><code>&lt;?php\nuse Aazsamir\\Libphpsky\\Model\\Meta\\ATProtoMetaClient;\n\n$client = new ATProtoMetaClient();\n$resolved = $client-&gt;comAtprotoIdentityResolveHandle()-&gt;query('bsky.app');\n$posts = $client-&gt;appBskyFeedGetAuthorFeed()-&gt;query($resolve-&gt;did);\n\nvar_dump($posts);\n</code></pre> <p>Using the <code>ATProtoMetaClient</code> is the easiest way to interact with the AT Protocol. Note that the names of methods are coming directly from the AT Protocol definition.</p> <p><code>com.atproto.identity.resolveHandle</code> -&gt; <code>comAtprotoIdentityResolveHandle</code></p> <p>However, you can also use plain libphpsky types:</p> <pre><code>&lt;?php\nuse Aazsamir\\Libphpsky\\Model\\Com\\Atproto\\Identity\\ResolveHandle\\ResolveHandle;\nuse Aazsamir\\Libphpsky\\Model\\App\\Bsky\\Feed\\GetAuthorFeed\\GetAuthorFeed;\n\n$resolveHandle = ResolveHandle::default();\n$resolved = $resolveHandle-&gt;query('bsky.app');\n\n$getAuthorFeed = GetAuthorFeed::default();\n$posts = $getAuthorFeed-&gt;query($resolved-&gt;did);\n\nvar_dump($posts);\n</code></pre>"},{"location":"01_getting_started/#authorization","title":"Authorization","text":"<p>Most of the ATProto methods require authorization. Default implementation handles this for you, you only need to provide <code>ATPROTO_LOGIN</code> and <code>ATPROTO_PASSWORD</code> environment variables.</p> <p>You should use an app password instead of your main password. Learn more</p> <p>If you want to handle authorization by yourself, you need to obtain a JWT token and pass it to the client:</p> <pre><code>&lt;?php\nuse Aazsamir\\Libphpsky\\Model\\Com\\Atproto\\Server\\CreateSession;\nuse Aazsamir\\Libphpsky\\Model\\App\\Bsky\\Actor\\GetProfile\\GetProfile;\nuse Aazsamir\\Libphpsky\\Model\\Meta\\ATProtoMetaClient;\n\n$createSession = CreateSession\\CreateSession::default();\n$input = CreateSession\\Input::new(\n    login: 'yourlogin.bsky.social',\n    password: 'yourpassword',\n)\n\n$session = $createSession-&gt;procedure($input);\n\n$getProfile = GetProfile::default();\n$profile = $getProfile-&gt;withAuth($session-&gt;accessJwt)-&gt;query('bsky.app');\n\n// or directly to meta client\n$client = new ATProtoMetaClient(token: $session-&gt;accessJwt);\n</code></pre> <p>You can also provide your own client implementation, to handle authorization on a different layer. See the Client section for more details.</p>"},{"location":"02_client/","title":"Client","text":"<p>Every query and procedure calls a <code>ATProtoClientInterface</code> to send request.</p>"},{"location":"02_client/#builder","title":"Builder","text":"<p>You may build a client by yourself, using <code>ATProtoClientBuilder</code>:</p> <pre><code>&lt;?php\nuse Aazsamir\\Libphpsky\\Client\\ATProtoClientBuilder;\nuse Aazsamir\\Libphpsky\\Client\\AuthConfig;\nuse Aazsamir\\Libphpsky\\Client\\Session\\MemorySessionStore;\nuse Symfony\\Component\\Cache\\Adapter\\FilesystemAdapter;\n\n// use default implementation\n$client = ATProtoClientBuilder::default();\n// or build your own\n$client = ATProtoClientBuilder::default()\n    -&gt;authConfig(new AuthConfig('login', 'password'))\n    -&gt;sessionStore(new MemorySessionStore())\n    -&gt;useAsync(true)\n    -&gt;useQueryCache(true)\n    -&gt;cache(new FilesystemAdapter())\n    -&gt;build();\n\n// pass it as a dependency\n$resolveHandle = new ResolveHandle($client);\n// or use withClient method\n$resolveHandle = (new ResolveHandle())-&gt;withClient($client);\n// if you prefer meta client\n$metaClient = new ATProtoMetaClient($client);\n</code></pre>"},{"location":"02_client/#custom-client","title":"Custom client","text":"<p>If you need to bring your own implementation, you can implement <code>ATProtoClientInterface</code>:</p> <pre><code>&lt;?php\nuse Psr\\Http\\Message\\RequestInterface;\nuse Psr\\Http\\Message\\ResponseInterface;\n\nclass MyClient implements ATProtoClientInterface\n{\n    public function sendRequest(RequestInterface $request): ResponseInterface\n    {\n        // ...\n    }\n}\n</code></pre>"},{"location":"02_client/#decorators","title":"Decorators","text":"<p>You can extend your client with existing decorators:</p> <pre><code>&lt;?php\nuse Aazsamir\\Libphpsky\\Client\\AuthConfig;\nuse Aazsamir\\Libphpsky\\Client\\AuthAwareClient;\nuse Aazsamir\\Libphpsky\\Client\\ErrorAwareClient;\nuse Aazsamir\\Libphpsky\\Client\\QueryCacheClient;\nuse Aazsamir\\Libphpsky\\Client\\Session\\MemorySessionStore;\n\n$client = new AuthAwareClient(\n    decorated: new ErrorAwareClient(\n        decorated: new QueryCacheClient(\n            decorated: new MyClient(),\n        ),\n    ),\n    authConfig: new AuthConfig('login', 'password'),\n    sessionStore: new MemorySessionStore(),\n)\n</code></pre>"},{"location":"02_client/#amphp-support","title":"Amphp support","text":"<p>Libphpsky provides client with amphp support. You can use <code>AmphpClientAdapter</code>:</p> <pre><code>&lt;?php\nuse Aazsamir\\Libphpsky\\Client\\AmphpClientAdapter;\nuse Aazsamir\\Libphpsky\\Client\\ATProtoClientBuilder;\nuse Amp\\Http\\Client\\HttpClientBuilder;\n\n// using builder\n$client = ATProtoClientBuilder::default()\n    -&gt;useAsync(true)\n    -&gt;build();\n\n// or using adapter\n$client = new AmphpClientAdapter(\n    HttpClientBuilder::buildDefault(),\n);\n\n$getProfile = new GetProfile($client);\n$actors = ['bsky.app', 'steampowered.com'];\n$futures = [];\n\nforeach ($actors as $actor) {\n    $futures[] = \\Amp\\async(fn() =&gt; $getProfile-&gt;query($actor));\n}\n\n[$errors, $profiles] = \\Amp\\Future\\awaitAll($futures);\n</code></pre>"},{"location":"03_model/","title":"Model","text":"<p>Libphpsky data model is fully generated from the AT Protocol definition. Let's take a look at the generation process.</p>"},{"location":"03_model/#generation","title":"Generation","text":"<p>Generated classes are located in the <code>Aazsamir\\Libphpsky\\Model</code> namespace.</p> <p>Given the following AT Protocol definition:</p> <p><pre><code>{\n  \"lexicon\": 1,\n  \"id\": \"com.atproto.identity.resolveHandle\",\n  \"defs\": {\n    \"main\": {\n      \"type\": \"query\",\n      \"description\": \"Resolves a handle (domain name) to a DID.\",\n      \"parameters\": {\n        \"type\": \"params\",\n        \"required\": [\"handle\"],\n        \"properties\": {\n          \"handle\": {\n            \"type\": \"string\",\n            \"format\": \"handle\",\n            \"description\": \"The handle to resolve.\"\n          }\n        }\n      },\n      \"output\": {\n        \"encoding\": \"application/json\",\n        \"schema\": {\n          \"type\": \"object\",\n          \"required\": [\"did\"],\n          \"properties\": {\n            \"did\": { \"type\": \"string\", \"format\": \"did\" }\n          }\n        }\n      }\n    }\n  }\n}\n</code></pre> Let's look at the resulting class:</p> <pre><code>&lt;?php\n\nnamespace Aazsamir\\Libphpsky\\Model\\Com\\Atproto\\Identity\\ResolveHandle;\n\n/**\n * Resolves a handle (domain name) to a DID.\n * query\n */\nclass ResolveHandle implements \\Aazsamir\\Libphpsky\\Action\n{\n    use \\Aazsamir\\Libphpsky\\Generator\\Prefab\\IsQuery;\n\n    public const NAME = 'main';\n    public const ID = 'com.atproto.identity.resolveHandle';\n\n    public static function id(): string\n    {\n        return self::ID;\n    }\n\n    public static function name(): string\n    {\n        return self::NAME;\n    }\n\n    public function query(string $handle): Output\n    {\n        return \\Aazsamir\\Libphpsky\\Model\\Com\\Atproto\\Identity\\ResolveHandle\\Output::fromArray($this-&gt;request($this-&gt;argsWithKeys(func_get_args())));\n    }\n}\n</code></pre> <p>First, <code>id</code> equals <code>com.atproto.identity.resolveHandle</code>.</p> <p>It corresponds to the <code>Aazsamir\\Libphpsky\\Model\\Com\\Atproto\\Identity\\ResolveHandle</code> namespace.</p> <p>By convention, the <code>main</code> object is the default method of lexicon, so the class is named <code>ResolveHandle</code>.</p> <p>It is of type <code>query</code>, so generated class has a <code>query</code> method.</p> <p>It has a single property <code>handle</code>, so the <code>query</code> method has a single parameter <code>$handle</code> with type <code>string</code>.</p> <p>The output is an object with a single property <code>did</code>, so the <code>query</code> method returns an object called <code>Output</code> with a single property <code>$did</code>.</p>"},{"location":"03_model/#meta-client","title":"Meta client","text":"<p><code>ATProtoMetaClient</code> is also fully generated, and aggregates all the methods from the AT Protocol.</p> <p>Given previous example of <code>com.atproto.identity.resolveHandle</code>, the <code>ATProtoMetaClient</code> will have a method <code>comAtprotoIdentityResolveHandle</code>.</p> <pre><code>&lt;?php\n\nnamespace Aazsamir\\Libphpsky\\Model\\Meta;\n\nuse Aazsamir\\Libphpsky\\Model\\Com\\Atproto\\Identity\\ResolveHandle;\n\nclass ATProtoMetaClient\n{\n    /**\n     * Resolves a handle (domain name) to a DID.\n     */\n    public function comAtprotoIdentityResolveHandle(): ResolveHandle\\Output\n    {\n        return new ResolveHandle\\ResolveHandle(\n          $this-&gt;client,\n          $this-&gt;typeResolver,\n          $this-&gt;token,\n        );\n    }\n    // ...\n}\n</code></pre> <p>You can see, that it's only a convenient wrapper around all the generated classes.</p>"},{"location":"04_subscriptions/","title":"Subscriptions","text":"<p>Libphpsky supports subscriptions over WebSockets, thanks to <code>phrity/websocket</code> and Jetstream.</p>"},{"location":"04_subscriptions/#usage","title":"Usage","text":"<pre><code>&lt;?php\n\nuse Aazsamir\\Libphpsky\\Jetstream\\WebSocketClientFactory;\nuse Aazsamir\\Libphpsky\\Jetstream\\WssClient;\nuse Aazsamir\\Libphpsky\\Model\\App\\Bsky\\Feed\\Like\\Like;\n\n$factory = new WebSocketClientFactory();\n$client = new WssClient($factory);\n\n$eventsStream = $client-&gt;subscribe(\n    wantedCollections: [\n        Like::id(),\n    ]\n);\n\n$max = 10000;\n\nforeach ($eventsStream as $i =&gt; $event) {\n    dump($event);\n\n    if ($i &gt; $max) {\n        $client-&gt;stop();\n    }\n}\n</code></pre> <p>So how does it work?</p> <p><code>WssClient</code> demands a <code>\\Websocket\\Client</code> instance, which is created by <code>WebSocketClientFactory</code>. The factory is responsible for creating a WebSocket client with the correct configuration.</p> <p>It returns a <code>\\Generator&lt;int, Aazsamir\\Libphpsky\\Jetstream\\Model\\Event&gt;</code> that can be iterated over to receive events. The client can be stopped during by calling the <code>stop</code> method.</p>"},{"location":"04_subscriptions/#events","title":"Events","text":"<p>Right now, Jetstream supports the following events:</p> <ul> <li>Commit<ul> <li>Create</li> <li>Update</li> <li>Delete</li> </ul> </li> <li>Account</li> <li>Identity</li> </ul> <p>Check the Jetstream repository for more information on the events.</p> <p>You can find the working example in the examples/Subscriptions directory.</p>"},{"location":"05_custom_lexicons/","title":"Custom Lexicons","text":"<p>Libphpsky supports generating types for custom lexicons. You can use any lexicon that follows the AT Protocol Lexicon Specification. Custom lexicons may even reference other lexicons, including the native atproto lexicons.</p>"},{"location":"05_custom_lexicons/#generating-types","title":"Generating Types","text":"<pre><code>&lt;?php\n// file: generate-fm-teal.php\n\nrequire __DIR__ . '/vendor/autoload.php';\n\n$config = MakeConfig::default()-&gt;with(\n    new MakeConfigEntry(\n        lexiconsPath: __DIR__ . '/lexicons/fm.teal.alpha',\n        // path and namespace must follow PSR-4\n        path: __DIR__ . 'src/FmTeal',\n        namespace: 'App\\FmTeal',\n    ),\n);\n\n// this will generate the classes in the specified path\n$generator = Generator::default();\n$generator-&gt;generate($config);\n</code></pre> <p>And run script with <code>php generate-fm-teal.php</code></p>"},{"location":"05_custom_lexicons/#usage","title":"Usage","text":"<p>After successful generation, you can use the generated client in your code. You need to create a <code>TypeResolver</code> with the same configuration as used during generation.</p> <pre><code>&lt;?php\n\nuse App\\FmTeal\\Meta\\ATProtoMetaClient;\n\n$config = MakeConfig::default()-&gt;with(\n    new MakeConfigEntry(\n        lexiconsPath: __DIR__ . '/lexicons/fm.teal.alpha',\n        path: __DIR__ . '/FmTeal',\n        namespace: 'Examples\\CustomLexicons\\FmTeal',\n    ),\n);\n\n$typeResolver = new TypeResolver($config);\n\n$client = new ATProtoMetaClient(\n    typeResolver: $typeResolver,\n);\n\n$client\n    -&gt;fmTealAlphaActorGetProfile()\n    -&gt;withEndpoint('https://example-fm-server.com')\n    -&gt;query('some.actor');\n</code></pre> <p>These lexicons can also be used with subscriptions, you just need to pass the same <code>TypeResolver</code> to the <code>MessageAdapter</code>.</p> <pre><code>&lt;?php\n\n$client = WssClient::default(\n    messageAdapter: new MessageAdapter($typeResolver),\n);\n\n$eventsStream = $client-&gt;subscribe(\n    wantedCollections: [\n        'fm.teal.*',\n    ]\n);\n\nforeach ($eventsStream as $i =&gt; $event) {\n    if (!$event instanceof CommitEvent) {\n        continue;\n    }\n\n    // record is correctly typed as \\App\\FmTeal\\SomeRecord\n    var_dump($event-&gt;commit-&gt;record);\n}\n</code></pre> <p>You can find the working example in the examples/CustomLexicons directory.</p>"}]}