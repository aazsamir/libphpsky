{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Getting started","text":"<p>Libphpsky is a PHP library for interacting with AT Protocol.</p>"},{"location":"#installation","title":"Installation","text":"<p>You can install the package via composer:</p> <pre><code>composer require aazsamir/libphpsky\n</code></pre> <p>If you are using Laravel, you can use the libphpsky-laravel package.</p> <pre><code>composer require aazsamir/libphpsky-laravel\n</code></pre> <p>If you are using Symfony, you can use the libphpsky-symfony package.</p> <pre><code>composer require aazsamir/libphpsky-symfony\n</code></pre>"},{"location":"#usage","title":"Usage","text":"<p>Get list of posts from a <code>bsky.app</code> user:</p> <pre><code>&lt;?php\nuse Aazsamir\\Libphpsky\\Model\\Meta\\ATProtoMetaClient;\n\n$client = new ATProtoMetaClient();\n$resolved = $client-&gt;comAtprotoIdentityResolveHandle()-&gt;query('bsky.app');\n$posts = $client-&gt;appBskyFeedGetAuthorFeed()-&gt;query($resolve-&gt;did);\n\nvar_dump($posts);\n</code></pre> <p>Using the <code>ATProtoMetaClient</code> is the easiest way to interact with the AT Protocol. Note that the names of methods are coming directly from the AT Protocol definition.</p> <p><code>com.atproto.identity.resolveHandle</code> -&gt; <code>comAtprotoIdentityResolveHandle</code></p> <p>However, you can also use plain libphpsky types:</p> <pre><code>&lt;?php\nuse Aazsamir\\Libphpsky\\Model\\Com\\Atproto\\Identity\\ResolveHandle\\ResolveHandle;\nuse Aazsamir\\Libphpsky\\Model\\App\\Bsky\\Feed\\GetAuthorFeed\\GetAuthorFeed;\n\n$resolveHandle = ResolveHandle::default();\n$resolved = $resolveHandle-&gt;query('bsky.app');\n\n$getAuthorFeed = GetAuthorFeed::default();\n$posts = $getAuthorFeed-&gt;query($resolved-&gt;did);\n\nvar_dump($posts);\n</code></pre>"},{"location":"#authorization","title":"Authorization","text":"<p>Most of the ATProto methods require authorization. Default implementation handles this for you, you only need to provide <code>ATPROTO_LOGIN</code> and <code>ATPROTO_PASSWORD</code> environment variables.</p> <p>You should use an app password instead of your main password. Learn more</p> <p>If you want to handle authorization by yourself, you need to obtain a JWT token and pass it to the client:</p> <pre><code>&lt;?php\nuse Aazsamir\\Libphpsky\\Model\\Com\\Atproto\\Server\\CreateSession;\nuse Aazsamir\\Libphpsky\\Model\\App\\Bsky\\Actor\\GetProfile\\GetProfile;\nuse Aazsamir\\Libphpsky\\Model\\Meta\\ATProtoMetaClient;\n\n$createSession = CreateSession\\CreateSession::default();\n$input = CreateSession\\Input::new(\n    login: 'yourlogin.bsky.social',\n    password: 'yourpassword',\n)\n\n$session = $createSession-&gt;procedure($input);\n\n$getProfile = GetProfile::default();\n$profile = $getProfile-&gt;withAuth($session-&gt;accessJwt)-&gt;query('bsky.app');\n\n// or directly to meta client\n$client = new ATProtoMetaClient(token: $session-&gt;accessJwt);\n</code></pre> <p>You can also provide your own client implementation, to handle authorization on a different layer. See the Client section for more details.</p>"},{"location":"client/","title":"Client","text":"<p>Every query and procedure calls a <code>ATProtoClientInterface</code> to send request.</p>"},{"location":"client/#builder","title":"Builder","text":"<p>You may build a client by yourself, using <code>ATProtoClientBuilder</code>:</p> <pre><code>&lt;?php\nuse Aazsamir\\Libphpsky\\Client\\ATProtoClientBuilder;\nuse Aazsamir\\Libphpsky\\Client\\AuthConfig;\nuse Aazsamir\\Libphpsky\\Client\\Session\\MemorySessionStore;\nuse Symfony\\Component\\Cache\\Adapter\\FilesystemAdapter;\n\n// use default implementation\n$client = ATProtoClientBuilder::default();\n// or build your own\n$client = ATProtoClientBuilder::default()\n    -&gt;authConfig(new AuthConfig('login', 'password'))\n    -&gt;sessionStore(new MemorySessionStore())\n    -&gt;useAsync(true)\n    -&gt;useQueryCache(true)\n    -&gt;cache(new FilesystemAdapter())\n    -&gt;build();\n\n// pass it as a dependency\n$resolveHandle = new ResolveHandle($client);\n// or use withClient method\n$resolveHandle = (new ResolveHandle())-&gt;withClient($client);\n// if you prefer meta client\n$metaClient = new ATProtoMetaClient($client);\n</code></pre>"},{"location":"client/#custom-client","title":"Custom client","text":"<p>If you need to bring your own implementation, you can implement <code>ATProtoClientInterface</code>:</p> <pre><code>&lt;?php\nuse Psr\\Http\\Message\\RequestInterface;\nuse Psr\\Http\\Message\\ResponseInterface;\n\nclass MyClient implements ATProtoClientInterface\n{\n    public function sendRequest(RequestInterface $request): ResponseInterface\n    {\n        // ...\n    }\n}\n</code></pre>"},{"location":"client/#decorators","title":"Decorators","text":"<p>You can extend your client with existing decorators:</p> <pre><code>&lt;?php\nuse Aazsamir\\Libphpsky\\Client\\AuthConfig;\nuse Aazsamir\\Libphpsky\\Client\\AuthAwareClient;\nuse Aazsamir\\Libphpsky\\Client\\ErrorAwareClient;\nuse Aazsamir\\Libphpsky\\Client\\QueryCacheClient;\nuse Aazsamir\\Libphpsky\\Client\\Session\\MemorySessionStore;\n\n$client = new AuthAwareClient(\n    decorated: new ErrorAwareClient(\n        decorated: new QueryCacheClient(\n            decorated: new MyClient(),\n        ),\n    ),\n    authConfig: new AuthConfig('login', 'password'),\n    sessionStore: new MemorySessionStore(),\n)\n</code></pre>"},{"location":"client/#amphp-support","title":"Amphp support","text":"<p>Libphpsky provides client with amphp support. You can use <code>AmphpClientAdapter</code>:</p> <pre><code>&lt;?php\nuse Aazsamir\\Libphpsky\\Client\\AmphpClientAdapter;\nuse Aazsamir\\Libphpsky\\Client\\ATProtoClientBuilder;\nuse Amp\\Http\\Client\\HttpClientBuilder;\n\n// using builder\n$client = ATProtoClientBuilder::default()\n    -&gt;useAsync(true)\n    -&gt;build();\n\n// or using adapter\n$client = new AmphpClientAdapter(\n    HttpClientBuilder::buildDefault(),\n);\n\n$getProfile = new GetProfile($client);\n$actors = ['bsky.app', 'steampowered.com'];\n$futures = [];\n\nforeach ($actors as $actor) {\n    $futures[] = \\Amp\\async(fn() =&gt; $getProfile-&gt;query($actor));\n}\n\n[$errors, $profiles] = \\Amp\\Future\\awaitAll($futures);\n</code></pre>"},{"location":"model/","title":"Model","text":"<p>Libphpsky data model is fully generated from the AT Protocol definition. Let's take a look at the generation process.</p>"},{"location":"model/#generation","title":"Generation","text":"<p>Generated classes are located in the <code>Aazsamir\\Libphpsky\\Model</code> namespace.</p> <p>Given the following AT Protocol definition:</p> <p><pre><code>{\n  \"lexicon\": 1,\n  \"id\": \"com.atproto.identity.resolveHandle\",\n  \"defs\": {\n    \"main\": {\n      \"type\": \"query\",\n      \"description\": \"Resolves a handle (domain name) to a DID.\",\n      \"parameters\": {\n        \"type\": \"params\",\n        \"required\": [\"handle\"],\n        \"properties\": {\n          \"handle\": {\n            \"type\": \"string\",\n            \"format\": \"handle\",\n            \"description\": \"The handle to resolve.\"\n          }\n        }\n      },\n      \"output\": {\n        \"encoding\": \"application/json\",\n        \"schema\": {\n          \"type\": \"object\",\n          \"required\": [\"did\"],\n          \"properties\": {\n            \"did\": { \"type\": \"string\", \"format\": \"did\" }\n          }\n        }\n      }\n    }\n  }\n}\n</code></pre> Let's look at the resulting class:</p> <pre><code>&lt;?php\n\nnamespace Aazsamir\\Libphpsky\\Model\\Com\\Atproto\\Identity\\ResolveHandle;\n\n/**\n * Resolves a handle (domain name) to a DID.\n * query\n */\nclass ResolveHandle implements \\Aazsamir\\Libphpsky\\Action\n{\n    use \\Aazsamir\\Libphpsky\\Generator\\Prefab\\IsQuery;\n\n    public const NAME = 'main';\n    public const ID = 'com.atproto.identity.resolveHandle';\n\n    public static function id(): string\n    {\n        return self::ID;\n    }\n\n    public static function name(): string\n    {\n        return self::NAME;\n    }\n\n    public function query(string $handle): Output\n    {\n        return \\Aazsamir\\Libphpsky\\Model\\Com\\Atproto\\Identity\\ResolveHandle\\Output::fromArray($this-&gt;request($this-&gt;argsWithKeys(func_get_args())));\n    }\n}\n</code></pre> <p>First, <code>id</code> equals <code>com.atproto.identity.resolveHandle</code>.</p> <p>It corresponds to the <code>Aazsamir\\Libphpsky\\Model\\Com\\Atproto\\Identity\\ResolveHandle</code> namespace.</p> <p>By convention, the <code>main</code> object is the default method of lexicon, so the class is named <code>ResolveHandle</code>.</p> <p>It is of type <code>query</code>, so generated class has a <code>query</code> method.</p> <p>It has a single property <code>handle</code>, so the <code>query</code> method has a single parameter <code>$handle</code> with type <code>string</code>.</p> <p>The output is an object with a single property <code>did</code>, so the <code>query</code> method returns an object called <code>Output</code> with a single property <code>$did</code>.</p>"},{"location":"model/#meta-client","title":"Meta client","text":"<p><code>ATProtoMetaClient</code> is also fully generated, and aggregates all the methods from the AT Protocol.</p> <p>Given previous example of <code>com.atproto.identity.resolveHandle</code>, the <code>ATProtoMetaClient</code> will have a method <code>comAtprotoIdentityResolveHandle</code>.</p> <pre><code>&lt;?php\n\nnamespace Aazsamir\\Libphpsky\\Model\\Meta;\n\nclass ATProtoMetaClient\n{\n    /**\n     * Resolves a handle (domain name) to a DID.\n     */\n    public function comAtprotoIdentityResolveHandle(): \\Aazsamir\\Libphpsky\\Model\\Com\\Atproto\\Identity\\ResolveHandle\\Output {\n        return new \\Aazsamir\\Libphpsky\\Model\\Com\\Atproto\\Identity\\ResolveHandle\\ResolveHandle($this-&gt;client, $this-&gt;token);\n    }\n    // ...\n}\n</code></pre> <p>You can see, that it's only a convenient wrapper around all the generated classes.</p>"},{"location":"subscriptions/","title":"Subscriptions","text":"<p>Libphpsky supports subscriptions over WebSockets, thanks to <code>phrity/websocket</code> and Jetstream.</p>"},{"location":"subscriptions/#usage","title":"Usage","text":"<pre><code>&lt;?php\n\nuse Aazsamir\\Libphpsky\\Jetstream\\WebSocketClientFactory;\nuse Aazsamir\\Libphpsky\\Jetstream\\WssClient;\nuse Aazsamir\\Libphpsky\\Model\\App\\Bsky\\Feed\\Like\\Like;\n\n$factory = new WebSocketClientFactory();\n$client = new WssClient($factory);\n\n$eventsStream = $client-&gt;subscribe(\n    wantedCollections: [\n        Like::id(),\n    ]\n);\n\n$max = 10000;\n\nforeach ($eventsStream as $i =&gt; $event) {\n    dump($event);\n\n    if ($i &gt; $max) {\n        $client-&gt;stop();\n    }\n}\n</code></pre> <p>So how does it work?</p> <p><code>WssClient</code> demands a <code>\\Websocket\\Client</code> instance, which is created by <code>WebSocketClientFactory</code>. The factory is responsible for creating a WebSocket client with the correct configuration.</p> <p>It returns a <code>\\Generator&lt;int, Aazsamir\\Libphpsky\\Jetstream\\Model\\Event&gt;</code> that can be iterated over to receive events. The client can be stopped during by calling the <code>stop</code> method.</p>"},{"location":"subscriptions/#events","title":"Events","text":"<p>Right now, Jetstream supports the following events:</p> <ul> <li>Commit<ul> <li>Create</li> <li>Update</li> <li>Delete</li> </ul> </li> <li>Account</li> <li>Identity</li> </ul> <p>Check the Jetstream repository for more information on the events.</p> <p>https://github.com/bluesky-social/jetstream</p>"}]}